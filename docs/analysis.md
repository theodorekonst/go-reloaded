# Analysis – go-reloaded

## 1️⃣ Περιγραφή προβλήματος (με δικά μου λόγια)
Το project **go-reloaded** είναι ένα εργαλείο διόρθωσης κειμένου γραμμένο σε Go.  
Διαβάζει ένα αρχείο εισόδου που περιέχει λέξεις και ειδικές "εντολές" όπως `(hex)`, `(up, 2)` ή `(low)`.  
Αφού εντοπίσει αυτές τις εντολές, το πρόγραμμα εφαρμόζει τους αντίστοιχους μετασχηματισμούς και γράφει το τελικό διορθωμένο κείμενο σε νέο αρχείο εξόδου.  
Στόχος είναι να κατανοήσουμε πώς να χειριζόμαστε αρχεία, να αναλύουμε strings και να χτίζουμε modular αρχιτεκτονική.

---

## 2️⃣ Κανόνες (με παραδείγματα)

1. **(hex)** → Μετατρέπει την **προηγούμενη λέξη** από δεκαεξαδικό σε δεκαδικό.  
   `1E (hex) → 30`
2. **(bin)** → Μετατρέπει την **προηγούμενη λέξη** από δυαδικό σε δεκαδικό.  
   `10 (bin) → 2`
3. **(up) / (low) / (cap)** → Αλλάζει τη γραφή της **προηγούμενης λέξης**.  
   `go (up) → GO`  
   `LOUD (low) → loud`  
   `bridge (cap) → Bridge`
4. **(up|low|cap, n)** → Εφαρμόζει την αλλαγή στις **n προηγούμενες λέξεις** (μετράω μόνο λέξεις).  
   `This is so exciting (up, 2) → This is SO EXCITING`
5. **Στίξη** `. , ! ? : ;` → Κολλητή αριστερά στη λέξη πριν, **ένα κενό** μετά.  
   Ομαδοποιήσεις όπως `...`, `!?`, `?!` παραμένουν ενιαίες.  
   `I was thinking ... You were right → I was thinking... You were right`
6. **Quotes `' … '`** → Καμία απόσταση **μέσα** στα quotes.  
   `' awesome ' → 'awesome'`, `' many words here ' → 'many words here'`
7. **`a → an`** → Αν η επόμενη λέξη (αγνοώντας κενά/κόμματα) ξεκινά με **φωνήεν** ή **h**.  
   `a untold → an untold`, `a, honest → an, honest`

---

## 3️⃣ Edge cases & αποφάσεις

- Αν ο αριθμός δεν είναι έγκυρος: `ZZ (hex)` ή `102 (bin)` → κρατάω τη λέξη, αφαιρώ το tag.  
- `(up, 0)` ή λάθος σύνταξη → αγνοείται με ασφάλεια.  
- Στα `(up, n)` μετράω **μόνο** τις λέξεις, όχι σημεία στίξης ή κενά.  
- Το `a→an` ισχύει ακόμα κι αν υπάρχει κόμμα ανάμεσα.  
- Το `...` θεωρείται **ενιαίο σημείο στίξης**.

---

## 4️⃣ Pipeline vs FSM (σύγκριση & επιλογή)

### 🔹 Τι είναι “Stages” (Pipeline) vs “States” (FSM)
- **Stage (Pipeline)** = Ένα **βήμα** επεξεργασίας. Παίρνει το αποτέλεσμα του προηγούμενου, το αλλάζει, και το στέλνει παρακάτω.  
- **State (FSM)** = Μια **κατάσταση** στην οποία βρίσκεται το πρόγραμμα (π.χ. "διαβάζω λέξη", "διαβάζω tag") και αλλάζει συμπεριφορά ανάλογα με την είσοδο.

---

### 🔸 Διάγραμμα Pipeline (σειρά βημάτων)

Input file
   ↓
[ Tokenize ]
   ↓
[ Numbers (hex/bin) ]
   ↓
[ Casing (up/low/cap[, n]) ]
   ↓
[ Articles (a→an) ]
   ↓
[ Punctuation ]
   ↓
[ Quotes ]
   ↓
Output file

---

### 🔸 Διάγραμμα FSM (ροή καταστάσεων)

[READ_WORD] -- '(' --> [READ_TAG] -- ')' --> [APPLY_RULE] --> back to [READ_WORD]

---

### 🧩 Πότε τι διαλέγω;

| Κριτήριο | Pipeline | FSM |
|-----------|-----------|------|
| Αναγνωσιμότητα | ✅ Καθαρό & modular | ❌ Πιο περίπλοκο (ένα μεγάλο loop) |
| Testing | ✅ Εύκολο (unit tests ανά στάση) | ❌ Δύσκολο (όλο το flow μαζί) |
| Προσθήκη νέου κανόνα | ✅ Νέα στάση | ❌ Αλλαγή στη λογική του FSM |
| Απόδοση | Λίγο πιο αργό | Λίγο πιο γρήγορο |
| Ιδανικό για | Μετασχηματισμούς δεδομένων | Real-time επεξεργασία |

---

### 🧠 Επιλογή
Επέλεξα το **Pipeline** γιατί:
- Είναι **καθαρό**, ευανάγνωστο και **εύκολο στον έλεγχο**.  
- Κάθε κανόνας είναι ανεξάρτητη μικρή συνάρτηση.  
- Μπορώ να κάνω testing ανά στάδιο.  
- Η επίδοση του FSM δεν είναι απαραίτητη σε αυτό το project.  

---
